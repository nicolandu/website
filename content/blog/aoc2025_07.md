+++
title = "Speedrun Advent of Code: 2025, jour&nbsp;7 (divulgâcheur)"
date = "2025-12-07"
updated = "2025-12-09"
description = "Parfois, un défi est prévisible!"

[taxonomies]
tags = ["Advent of Code", "rust"]
+++
<!-- ltex: language=fr -->

Pour [le défi Advent of Code d'aujourd'hui](https://adventofcode.com/2025/day/7), je devais trouver le nombre de points (`^`) où un faisceau de particules se sépare, en comptant uniquement les points sur lesquels frappe un faisceau.

```name=Exemple
  X

  ^

 ^ ^
```

```name=Faisceaux possibles
  X
  |
 |^|
 | |
|^|^|
| | |
```

Je pensais itérer, ligne par ligne, avec une paire de vecteurs de `bool` (un pour la rangée précédente et la rangée actuelle). Ils contiendraient les positions où un sous-faisceau est présent, et j'incrémenterais un compteur à chaque fois qu'un séparateur (`^`) est utilisé. Cependant, en ayant déjà résolu des défis Advent of Code dans le passé, j'avais une petite idée...

{{ admonition(type="warning", text="Le texte qui suit est un divulgâcheur. Si vous avez l'intention de relever le défi, allez-y, et revenez après! Sinon, cliquez pour révéler le texte.") }}

{% block_spoiler() %}
En général, la deuxième partie d'un défi Advent of Code est une variante de la première partie, et le défi d'aujourd'hui n'y faisait pas exception. Après quelques secondes de réflexion, je me suis dit que la partie&nbsp;2 consisterait probablement à calculer le nombre total de chemins possibles pour un sous-faisceau.

Ainsi, pour la partie&nbsp;1, au lieu d'utiliser deux vecteurs de `bool`, j'ai préféré utiliser deux vecteurs d'entiers (`Vec<u64>`) afin de *compter* le nombre de sous-faisceaux en un point donné. J'ai additionné le nombre de sous-faisceaux lorsque des chemins se rejoignaient, et j'ai compté les séparateurs où le nombre de faisceaux incidents était non nul, ce qui complétait la première partie.

Lorsque je suis passé à la partie&nbsp;2, ma suspicion s'est confirmée. J'ai recopié le code de la partie&nbsp;1, remplacé la valeur de retour `cnt` de la partie&nbsp;1 par `cur_row.iter().sum()` (la somme du nombre de sous-faisceaux de la dernière rangée), exécuté le code et envoyé le résultat. Comme [le pipeline de compilation Advent of Code que j'utilise](https://github.com/fspoettel/advent-of-code-rust) est assez automatisé, la dernière étape était un simple `cargo solve 7 --submit 2`, le tout sans lever les mains du clavier, en restant en ligne de commande (oui, j'utilise (Neo)vim).

Temps final pour la partie&nbsp;2: un maigre 57&nbsp;secondes.
{% end %}
