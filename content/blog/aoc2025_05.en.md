+++
title = "Advent of Code Speedrunning: 2025, Day&nbsp;5"
date = "2025-12-05"
updated = "2025-12-08"
description = "When you don't want to reinvent the wheel..."

[taxonomies]
tags = ["Advent of Code", "rust"]

[extra]
katex = true
+++
<!-- ltex: language=en -->

[Today's Advent of Code challenge](https://adventofcode.com/2025/day/5) involved calculating the union of massive ranges.

I first thought about the algorithms the challenge would entail. I *knew* that a na√Øve solution, such as a simple vector with all elements really wouldn't cut it (who has enough memory for 2<sup>50</sup> entries?), and getting any ad-hoc implementation to work right was guaranteed to be massive a pain in the neck.

With two ranges \\([a;b]\\) and \\([c;d]\\), I would have to check if they overlap \\({(a \\le c \\le b}\\) or \\({c \\le a \\le d)}\\), then merge them into a single range \\([\\min(a,c);\\max(b,d)]\\), over and over again, all while probably iterating a gazillion times over a vector of ranges when adding each new range.

Eventually, after [a quick search on crates.io](https://crates.io/search?q=range%20union), I found a neat little crate, [`range_union_find`](https://docs.rs/range_union_find/), that could allow me to not have to reinvent the wheel.

{{ aside(text="Here, *implementing* is used in a rather loose sense...") }}

"Implementing" an efficient strategy was as simple as this:

```bash
cargo add range_union_find
```

```rust
use range_union_find::RangeUnionFind;
```

It wasn't a matter of pride, but simply a matter of efficiency.

Moral of the story? Work smarter, not harder.
