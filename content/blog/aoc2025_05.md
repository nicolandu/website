+++
title = "Speedrun Advent of Code: 2025, jour&nbsp;5"
date = "2025-12-05"
updated = "2025-12-08"
description = "Quand on ne veut pas réinventer la roue..."

[taxonomies]
tags = ["Advent of Code", "rust"]

[extra]
katex = true
+++
<!-- ltex: language=fr -->

[Le défi Advent of Code d'aujourd'hui](https://adventofcode.com/2025/day/5) impliquait de calculer l'union d'immenses intervalles de nombres.

D'abord, j'ai pensé aux algorithmes qu'impliquerait le défi. Je *savais* qu'une solution naïve, comme un simple vecteur avec tous les éléments, ne ferait vraiment pas l'affaire. (Qui a assez de mémoire pour 2<sup>50</sup> éléments?) Aussi, faire fonctionner une implémentation *ad hoc* correctement promettait d'être pénible.

Avec deux intervalles \\([a;b]\\) et \\([c;d]\\), j'aurais à vérifier si elles se chevauchent \\({(a \\le c \\le b}\\) ou \\({c \\le a \\le d)}\\), puis les combiner en un seul intervalle \\([\\min(a,c);\\max(b,d)]\\), encore et encore, le tout en itérant un million de fois sur un vecteur d'intervalles en ajoutant chaque nouvel intervalle.

Éventuellement, après [une petite recherche sur `crates.io`](https://crates.io/search?q=range%20union), j'ai trouvé un beau *crate*, [`range_union_find`](https://docs.rs/range_union_find/), qui me permettrait d'éviter de réinventer la roue.

 «Implémenter[^1]» une stratégie efficace était aussi simple que ça:

```bash
cargo add range_union_find
```

```rust
use range_union_find::RangeUnionFind;
```

Ce n'était pas une question de fierté, mais simplement une question d'efficacité.

La morale de l'histoire? Travailler plus intelligemment, pas plus fort.

[^1]: Ici, *implémenter* est utilisé dans un sens plutôt large...
